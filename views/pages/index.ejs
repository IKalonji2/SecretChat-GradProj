<html lang="en">
<head>
    <%- include('../partials/head.ejs'); %>
</head>
<body class="container">
    <!-- <header>
    </header> -->
  
    <section class="container">
        <aside class="profiles-wrapper">
            <div class="user profile">
                <div class="img-holder"></div>
                <div class="username"><p>Username</p></div>
            </div>
            <div class="contacts">
                <div class="contacts-header">
                    <div class="username"><p>Username</p></div>
                </div>
                <% for( let index = 0; index < users.length; index++ ) { %>
                    <%- include('../partials/user.ejs', users[index]) %> 
                <% } %>
            </div>
        </aside>
  
        <%- include('../partials/chat.ejs', { user: { username: 'Lebo', imageUrl: 'https://randomuser.me/api/portraits/men/9.jpg', online: true  } }) %> 
    </section>

    <script src="./socket.io/socket.io.js"></script>
    <script src="/lib/openpgp.min.js"></script>
    <script>
        const socket = io({ autoConnect: false });
        const users = [];
        let myPrivateKey;        


        (async () => {
            const username = prompt("Please enter a username");
            socket.auth = { username, usernameSelected: true };

            const { privateKey, publicKey, revocationCertificate } = await openpgp.generateKey({
                type: 'ecc', // Type of the key, defaults to ECC
                curve: 'curve25519', // ECC curve name, defaults to curve25519
                userIDs: [{ name: username }], // you can pass multiple user IDs
                format: 'armored' // output key format, defaults to 'armored' (other options: 'binary' or 'object')
            });

            myPrivateKey = privateKey;
            socket.auth.publicKey = publicKey;
            socket.connect();

        })();

        socket.onAny((event, ...args) => {
            console.log(event, args);
        });

        const initReactiveProperties = (user) => {
            console.log('INIT USER:', user);
            user.connected = true;
            user.messages = [];
            user.hasNewMessages = false;
        };

        socket.on('user connected', (user) => {
            //FIX: new users not being added to user list correctly
            initReactiveProperties(user);
            users.push(user);
            console.log('USERS AFTER NEW CONNECTION:', users);
        });

        socket.on('connect', ()=>{
            console.log("test");
        });

        socket.on('users', (users) => {
            console.log('USERS[SOCKER.ON("USERS")] BEFORE SORT', users);
            users.forEach((user) => {
                user.self = user.userID === socket.id;
                initReactiveProperties(user);
            });
            console.log('USERS[SOCKER.ON("USERS")] AFTER IRP', users);
            // put the current user first, and sort by username
            this.users = users.sort((a, b) => {
                if (a.self) return -1;
                if (b.self) return 1;
                if (a.userInfo.username < b.userInfo.username) return -1;
                return a.userInfo.username > b.userInfo.username ? 1 : 0;
            });
            console.log('USERS[SOCKER.ON("USERS")] AFTER SORT', users);
        });


        socket.on("private message", async ({ content, from }) => {
            console.log(`message from ${from} saying \"${content}\"`);

            const sendingUser = users.find(user => user.userID === from);

            const privateKey = await openpgp.readKey({ armoredKey: myPrivateKey });
            const publicKey = await openpgp.readKey({ armoredKey: sendingUser.userInfo.publicKey });

            const message = await openpgp.readMessage({
                armoredMessage: content // parse armored message
            });

            const { data: decrypted, signatures } = await openpgp.decrypt({
                message,
                verificationKeys: publicKey,
                decryptionKeys: privateKey
            });

            console.log("MESSAGE:", decrypted);

            try {
                await signatures[0].verified; // throws on invalid signature
                console.log('Signature is valid');
            } catch (e) {
                throw new Error('Signature could not be verified: ' + e.message);
            }

        });

        function onUsernameSelection(event) {
            event.preventDefault();
            let username = document.getElementById('username').value;
            socket.auth = { username, usernameSelected: true }
            socket.connect();
        }

        function attachment(event) {
            event.preventDefault();
            alert('Attachment Pressed');
        }
        function emoticons(event) {
            event.preventDefault();
            alert('Emoticons Pressed');
        }
        async function sendMessage(event) {
            event.preventDefault();
            //TODO: Get user from selected chat
            const receivingUser = this.users.find(user => user.userInfo.username === "recipient");

            const formData = new FormData(event.target);
            const formProps = Object.fromEntries(formData);

            const textMessage = formProps['input-message'];
            const publicKey = await openpgp.readKey({ armoredKey: receivingUser.userInfo.publicKey });
            const privateKey = await openpgp.readKey({ armoredKey: myPrivateKey });
            const encrypted = await openpgp.encrypt({
                message: await openpgp.createMessage({ text: textMessage }), // input as Message object
                encryptionKeys: publicKey,
                signingKeys: privateKey
            });
            console.log(encrypted);

            socket.emit("private message", {
                content: encrypted,
                to: receivingUser.userID
            })
            alert(formProps['input-message']);
        }

        socket.on('connect_error', (err) => {
            if (err.message === 'invalid username') {
                this.usernameSelected = false;
            }
        });
    </script>
</body>
</html>