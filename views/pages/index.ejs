<html lang="en">
<head>
    <%- include('../partials/head.ejs'); %>
</head>
<body class="container">
    <!-- <header>
    </header> -->
  
    <section class="container">
        <aside class="profiles-wrapper">
            <div class="user profile">
                <div class="img-holder"></div>
                <div class="username"><p>Username</p></div>
            </div>
            <div class="contacts">
                <div class="contacts-header">
                    <div class="username"><p>Username</p></div>
                </div>
                <% for( let index = 0; index < users.length; index++ ) { %>
                    <%- include('../partials/user.ejs', users[index]) %> 
                <% } %>
            </div>
        </aside>
  
        <%- include('../partials/chat.ejs', { user: { username: 'Lebo', imageUrl: 'https://randomuser.me/api/portraits/men/9.jpg', online: true  } }) %> 
    </section>

    <script src="./socket.io/socket.io.js"></script>
    <script src="/lib/openpgp.min.js"></script>
    <script>
        const socket = io({ autoConnect: false });
        const users = [];
        let myPrivateKey;        
        let myUser;


        (async () => {
            const username = prompt("Please enter a username");
            socket.auth = { username, usernameSelected: true };

            const { privateKey, publicKey, revocationCertificate } = await openpgp.generateKey({
                type: 'ecc', // Type of the key, defaults to ECC
                curve: 'curve25519', // ECC curve name, defaults to curve25519
                userIDs: [{ name: username }], // you can pass multiple user IDs
                format: 'armored' // output key format, defaults to 'armored' (other options: 'binary' or 'object')
            });

            myPrivateKey = privateKey;
            socket.auth.publicKey = publicKey;
            socket.connect();

            
            const usernameField = document.querySelector('div.user.profile > div.username').getElementsByTagName("p").item(0);
            usernameField.textContent = username;

        })();

        socket.onAny((event, ...args) => {
            console.log(event, args);
        });

        const initReactiveProperties = (user) => {
            console.log('INIT USER:', user);
            user.connected = true;
            user.messages = [];
            user.hasNewMessages = false;
        };

        socket.on('user connected', (user) => {
            //FIX: new users not being added to user list correctly
            initReactiveProperties(user);
            this.users.push(user);
            console.log('USERS AFTER NEW CONNECTION:', this.users);
        });

        socket.on('connect', ()=>{
            console.log("test");
        });

        socket.on('users', (newUsers) => {
            this.users = [];
            console.log('USERS[SOCKER.ON("USERS")] BEFORE SORT', users);
            newUsers.forEach((user) => {
                if(user.userID === socket.id) {
                    user.self = true;
                    this.myUser = user;
                    console.log("MY USER:", this.myUser);
                }
                initReactiveProperties(user);
                this.users.push(user);
            });
            console.log('USERS[SOCKER.ON("USERS")] AFTER IRP', users);

            this.users = this.users.filter(user => !user.self);
            this.users.unshift(this.myUser);

            console.log('USERS[SOCKER.ON("USERS")] AFTER MOVE', this.users);
        });


        socket.on("private message", async ({ content, from }) => {
            console.log(`message from ${from} saying \"${content}\"`);

            console.log("USERS SEARCHED FOR SENDER:", this.users);
            const sendingUser = this.users.find(user => user.userID === from);

            const privateKey = await openpgp.readKey({ armoredKey: myPrivateKey });
            const publicKey = await openpgp.readKey({ armoredKey: sendingUser.userInfo.publicKey });

            const message = await openpgp.readMessage({
                armoredMessage: content // parse armored message
            });

            const { data: decrypted, signatures } = await openpgp.decrypt({
                message,
                verificationKeys: publicKey,
                decryptionKeys: privateKey
            });

            console.log("MESSAGE:", decrypted);

            try {
                await signatures[0].verified; // throws on invalid signature
                console.log('Signature is valid');
            } catch (e) {
                throw new Error('Signature could not be verified: ' + e.message);
            }
            
            addMessageToDisplay(sendingUser, decrypted, false);

            console.log("RECHECK SENDING USER:", this.users.find(user => user.userID === from));
        });

        function addMessageToDisplay(user, messageText, isFromSelf=false){
            user.messages.push({
                content: messageText,
                fromSelf: isFromSelf
            });
            const messagesDiv = document.getElementsByClassName("messages").item(0);
            const messageElement = document.createElement("div");

            if(isFromSelf) 
                messageElement.setAttribute("class", "user-messages");
            else {
                user.hasNewMessages = true;
                messageElement.setAttribute("class", "recipient-messages");
            }
            const messagePara = document.createElement("p");
            const messageContentNode = document.createTextNode(messageText);

            messagePara.appendChild(messageContentNode);
            messageElement.appendChild(messagePara);
            messagesDiv.appendChild(messageElement);
        }

        function attachment(event) {
            event.preventDefault();
            alert('Attachment Pressed');
        }
        function emoticons(event) {
            event.preventDefault();
            alert('Emoticons Pressed');
        }
        async function sendMessage(event) {
            event.preventDefault();
            //TODO: Get user from selected chat
            const receivingUserName = document.getElementById("recipient-username").innerText;
            console.log(receivingUserName);

            const receivingUser = this.users.find(user => user.userInfo.username === receivingUserName);
            console.log(receivingUser);

            const formData = new FormData(event.target);
            const formProps = Object.fromEntries(formData);

            const textMessage = formProps['input-message'];
            const publicKey = await openpgp.readKey({ armoredKey: receivingUser.userInfo.publicKey });
            const privateKey = await openpgp.readKey({ armoredKey: myPrivateKey });
            const encrypted = await openpgp.encrypt({
                message: await openpgp.createMessage({ text: textMessage }), // input as Message object
                encryptionKeys: publicKey,
                signingKeys: privateKey
            });
            console.log(encrypted);

            socket.emit("private message", {
                content: encrypted,
                to: receivingUser
            });

            addMessageToDisplay(receivingUser, textMessage, true);

        }

        socket.on('connect_error', (err) => {
            if (err.message === 'invalid username') {
                this.usernameSelected = false;
            }
        });

        socket.on('user disconnected', (socketId) => {
            this.users = this.users.filter(user => user.userID !== socketId);
        })
    </script>
</body>
</html>